/*
 * @(#)Object.java	1.74 10/03/23
 *
 * Копирайт (c) 2006, Oracle и/или его филиалы. Все права защищены.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Использовать в соответствии с лицензией.
 */

package java.lang;

/**
 * Класс {@code Object} является корнем иерархии классов. 
 * Каждый класс имеет {@code Object} как суперкласс. Все объекты, 
 * включая массивы, реализуют методы этого класса. 
 *
 * @author  unascribed
 * @version 1.74, 03/23/10
 * @see     java.lang.Class
 * @since   JDK1.0
 */
public class Object {

    private static native void registerNatives();
    static {
        registerNatives();
    }

    /**
     * Возвращает класс времени выполнения этого объекта. Возвращаемый объект
     * {@code Class} является объектом, который запирается статическими синхронизированными
     * ({@code static synchronized}) методами представляемого класса.
     *
     * <p><b>Фактическим типом результата является {@code Class<? extends |X|>}
     * где {@code |X|} является чистым статическим типом выражения,
     * на котором вызван {@code getClass}.</b> Например,
     * приведение не требуется для следующего фрагмента кода:</p>
     *
     * <p>
     * {@code Number n = 0;                             }<br>
     * {@code Class<? extends Number> c = n.getClass(); }
     * </p>
     *
     * @return Объект {@code Class}, представляющий класс времени выполнения
     *         для этого объекта.
     * @see    <a href="http://java.sun.com/docs/books/jls/">The Java
     *         Language Specification, Third Edition (15.8.2 Class
     *         Literals)</a>
     */
    public final native Class<?> getClass();

    /**
     * Возвращает значение хеш-кода для этого объекта. Этот метод предоставлен
     * специально для хеш-таблиц, такого плана, как
     * {@code java.util.Hashtable}. 
     * <p>
     * Общее соглашение для метода {@code hashCode}: 
     * <ul>
     * <li>Каждый раз при вызове на одном и том же объекте более, чем один 
     *     раз за время выполения приложения Java, метод <tt>hashCode</tt> 
     *     должен постоянно возвращать одно и то же число, не изменяя
     *     информацию, используемую в <tt>equals</tt> для сравнения.
     *     Это число не обязано быть постоянным в различных сессиях работы 
     *     приложения.
     * <li>Если два объекта идентичны в терминах метода <tt>equals(Object)</tt>,
     *     то вызов метода {@code hashCode} каждого из двух объектов
     *     должен выдать один и тот же результат.
     * <li><em>Не</em> требуется, чтобы, если два объекта неидентичны в терминах
     *     метода {@link java.lang.Object#equals(java.lang.Object)}, вызов
     *     метода <tt>hashCode</tt> для каждого из них давал различные
     *     значения.  Однако, программист должен знать, что выдача различных
     *     чисел для неидентичных объектов может повысить производительность
     *     хеш-таблиц.
     * </ul>
     * <p>
     * Поскольку это разумно практически, метод {@code hashCode}, определенный
     * классом <tt>Object</tt>, возвращает разные коды для разных объектов.
     * (Он обычно реализован конвертированием внутреннего адреса
     * объекта в целое значение, но эта техника реализации не требуется
     * языком программирования 
     * Java<font size="-2"><sup>TM</sup></font>.)
     *
     * @return  Значение хеш-кода для этого объекта.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.util.Hashtable
     */
    public native int hashCode();

    /**
     * Показывает, что некоторый другой объект "равен" этому.
     * <p>
     * Метод {@code equals} реализует отношение эквивалентности
     * на не-null ссылках объектов:
     * <ul>
     * <li>Он <i>рефлексивный</i>: для любого не-null значения ссылки
     *     {@code x}, {@code x.equals(x)} должен вернуть
     *     {@code true}.
     * <li>Он <i>симметричный</i>: для любых не-null значений ссылок
     *     {@code x} и {@code y}, {@code x.equals(y)}
     *     должен вернуть {@code true} тогда и только тогда, когда
     *     {@code y.equals(x)} возвращает {@code true}.
     * <li>Он <i>транзитивный</i>: для любых не-null значений ссылок
     *     {@code x}, {@code y} и {@code z}, если
     *     {@code x.equals(y)} возвращает {@code true} и
     *     {@code y.equals(z)} возвращает {@code true}, то
     *     {@code x.equals(z)} должен вернуть {@code true}.
     * <li>Он <i>непротиворечивый</i>: для любых не-null значений ссылок
     *     {@code x} и {@code y}, несколько вызовов
     *     <tt>x.equals(y)</tt> всегда возвращают {@code true}
     *     или всегда возвращают {@code false}, если никакая 
     *     информация, используемая при сравнении методом 
     *     {@code equals} объектов, не изменяется.
     * <li>Для любого не-null значения ссылки {@code x},
     *     {@code x.equals(null)} должен вернуть {@code false}.
     * </ul>
     * <p>
     * Метод <tt>equals</tt> для класса {@code Object} реализует 
     * наиболее характерное возможное отношение эквивалентности на объектах; 
     * так, для любых не-null значений ссылок {@code x} и {@code y}, 
     * этот метод возвращает {@code true} тогда и только тогда, когда
     * {@code x} и {@code y} ссылаются на один и тот же объект
     * ({@code x == y} имеет значение {@code true}).
     * <p>
     * Заметьте, что в общем случае необходимо переопределять метод 
     * <tt>hashCode</tt>, когда переопределен этот метод, чтобы поддерживать 
     * соглашение для метода <tt>hashCode</tt>, состоящее в том, что равные 
     * объекты должны иметь равные хеш-коды. 
     *
     * @param   obj   ссылка на объект для сравнения.
     * @return  {@code true} если этот объект такой же, как аргумент 
     *          obj; иначе {@code false}.
     * @see     #hashCode()
     * @see     java.util.Hashtable
     */
    public boolean equals(Object obj) {
        return (this == obj);
    }

    /**
     * Создает и возвращает копию этого объекта.  Точное значение
     * "копии" может зависеть от класса объекта. Общая идея состоит 
     * в том, что для любого объекта <tt>x</tt>, выражение:
     * <blockquote>
     * <pre>
     * x.clone() != x</pre></blockquote>
     * должно быть {@code true} и выражение:
     * <blockquote>
     * <pre>
     * x.clone().getClass() == x.getClass()</pre></blockquote>
     * должно быть <tt>true</tt>, но это не абсолютные требования. 
     * В то же время, типичен такой случай:
     * <blockquote>
     * <pre>
     * x.clone().equals(x)</pre></blockquote>
     * будет <tt>true</tt>, это не абсолютное требование. 
     * <p>
     * По соглашению, возвращаемый объект должен быть получен вызовом
     * <tt>super.clone</tt>. Если класс и все его суперклассы (исключая
     * <tt>Object</tt>), следуют этому соглашению, это будет случай, когда
     * <tt>x.clone().getClass() == x.getClass()</tt>.
     * <p>
     * По соглашению, объект, возвращаемый этим методом, должен быть 
     * независимым от этого объекта (который клонируется). Чтобы достигнуть
     * этой независимости, может быть необходимо изменить одно или несколько
     * полей объекта, возвращаемого вызовом <tt>super.clone</tt> прежде, 
     * чем возвратить его. Обычно это означает копирование любых изменяемых
     * объектов, которые входят во внутреннюю "глубокую структуру" клонируемого 
     * объекта и замену ссылок на эти объекты ссылками на их копии. Если 
     * класс содержит только примитивные поля или ссылки на неизменяемые 
     * объекты, то в этом случае обычно не требуется изменять какие-либо 
     * поля в объекте, возвращанном вызовом <tt>super.clone</tt>.
     * <p>
     * Метод <tt>clone</tt> для класса <tt>Object</tt> выполняет особую операцию
     * клонирования. Первое, если класс этого объекта не реализует интерфейс 
     * <tt>Cloneable</tt>, то кидается исключение <tt>CloneNotSupportedException</tt>.
     * Заметьте, что все массивы считаются реализующими интерфейс
     * <tt>Cloneable</tt>. 
     * В противном случае, метод создает новую инстанцию класса этого объекта
     * и инициализирует все ее поля существующим содержимым соответствующих
     * полей этого объекта, словно они были присвоены; само содержимое этих 
     * полей не копируется. Таким образом, этот метод выполняет "поверхностную копию" 
     * ("shallow copy") этого объекта, а не "глубокую копию" ("deep copy").
     * <p>
     * Сам класс <tt>Object</tt> не реализует интерфейс
     * <tt>Cloneable</tt>, поэтому вызов метода <tt>clone</tt> на объекте,
     * чей класс есть <tt>Object</tt>, приведет к выбросу исключения
     * во время выполнения.
     *
     * @return     Копия этой инстанции.
     * @exception  CloneNotSupportedException  если класс объекта не 
     *             поддерживает интерфейс {@code Cloneable}. Подклассы,
     *             которые переопределяют метод {@code clone}, также
     *             могут кидать это исключение, чтобы сообщить, что инстанция
     *             не может быть скопирована.
     * @see java.lang.Cloneable
     */
    protected native Object clone() throws CloneNotSupportedException;

    /**
     * Возвращает строковое представление объекта. В общем случае, метод
     * {@code toString} возвращает строку, которая 
     * "в текстовом виде" представляет этот объект. Результат должен быть
     * кратким, но информативным представлением, легко читаемым человеком.
     * 
     * Рекомендуется, чтобы все подклассы переопределяли этот метод.
     * <p>
     * Метод {@code toString} для класса {@code Object} 
     * возвращает строку, состоящую из имени класса, инстанцией которого 
     * объект является, символа собаки `{@code @}' и беззнакового 
     * шестнадцатеричного представления хеш-кода объекта. Другими словами, 
     * метод возвращает строку, эквивалентную значению выражения:
     * 
     * <blockquote>
     * <pre>
     * getClass().getName() + '@' + Integer.toHexString(hashCode())
     * </pre></blockquote>
     *
     * @return  Строковое представление объекта.
     */
    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }

    /**
     * Пробуждает один поток, ожидающий на мониторе этого объекта. Если
     * какие-то потоки ожидают на этом объекте, один из них выбирается для 
     * пробуждения. Выбор произволен и происходит по усмотрению реализации.
     * Поток начинает ожидать на мониторе объекта вызовом одного из
     * {@code wait} методов.
     * <p>
     * Пробужденный поток не будет способен продолжать выполнение, пока 
     * текущий поток не оставит блокировку этого объекта. Пробужденный поток 
     * конкурирует обычным способом с любыми другими потоками, которые
     * могли бы активно конкурировать за синхронизацию на этом объекте; например,
     * пробужденный поток не обладает никакими привелегиями или препятствиями
     * для того, чтобы стать следующим потоком, заблокировавшим этот объект.
     * <p>
     * Этот метод должен вызываться только потоком, владеющим монитором
     * этого объекта. Поток становится владельцем монитора объекта одним 
     * из следующих трех способов: 
     * <ul>
     * <li>Исполнением синхронизированного метода инстанции этого объекта. 
     * <li>Исполнением тела {@code synchronized}-выражения, 
     *     которое синхронизируется по этому объекту. 
     * <li>Для объектов типа {@code Class} исполнением 
     *     синхронизированного статического метода этого класса. 
     * </ul>
     * <p>В одно и то же время только один поток может владеть монитором объекта. 
     * <p>Про синхронизацию отлично написано на {@link http://www.skipy.ru/technics/synchronization.html}
     * 
     * @exception  IllegalMonitorStateException  если текущий поток не
     *             является владельцем монитора этого объекта.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    public final native void notify();

    /**
     * Пробуждает все потоки, ожидающие на мониторе этого объекта. 
     * Поток начинает ожидать на мониторе объекта вызовом одного из
     * {@code wait} методов.
     * <p>
     * Пробужденный поток не будет способен продолжать выполнение, пока 
     * текущий поток не оставит блокировку этого объекта. Пробужденный поток 
     * конкурирует обычным способом с любыми другими потоками, которые
     * могли бы активно конкурировать за синхронизацию на этом объекте; например,
     * пробужденный поток не обладает никакими привелегиями или препятствиями
     * для того, чтобы стать следующим потоком, заблокировавшим этот объект.
     * <p>
     * Этот метод должен вызываться только потоком, который владеет 
     * монитором этого объекта. Смотрите метод {@code notify} для 
     * описания способов, которыми поток может стать владельцем монитора.
     * <p>Про синхронизацию отлично написано на {@link http://www.skipy.ru/technics/synchronization.html}
     *
     * @exception  IllegalMonitorStateException  если текущий поток не
     *             является владельцем монитора этого объекта.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
    public final native void notifyAll();

    /**
     * Заставляет текущий поток ждать до тех пор, пока какой-нибудь другой 
     * поток не вызовет метод {@link java.lang.Object#notify()} или 
     * {@link java.lang.Object#notifyAll()} для этого объекта, или не 
     * пройдет указанное количество времени. 
     * <p>
     * Текущий поток должен владеть монитором этого объекта. 
     * <p>
     * Этот метод заставляет текущий поток (назовем его <var>T</var>) 
     * занять место в очереди ожидания для этого объекта и затем уступить
     * любые и все требования синхронизации на этом объекте. Поток <var>T</var> 
     * становится неактивным при планировании потоков и бездействует, 
     * пока не произойдет одна из четырех вещей:
     * <ul>
     * <li>Какой-нибудь другой поток вызовет метод <tt>notify</tt> для этого
     * объекта и поток <var>T</var> окажется тем произвольно выбранным 
     * потоком, который будет пробужден. 
     * <li>Какой-нибудь другой поток вызовет метод <tt>notifyAll</tt> для
     * этого объекта. 
     * <li>Какой-нибудь другой поток {@linkplain Thread#interrupt() прервет} 
     * поток <var>T</var>. 
     * <li>Пройдет, более или менее точно, указанное количество реального времени.
     * Однако, если <tt>timeout</tt> равен нулю, то реальное время не учитывается
     * и поток будет ждать, пока его не уведомят. 
     * </ul>
     * В этом случае поток <var>T</var> будет удален из очереди ожидания для 
     * этого объекта, и снова включен в планирование потоков. Он снова будет 
     * конкурировать обычным способом с другими потоками за право синхронизироваться 
     * на объекте; как только он получит контроль над объектом, все его 
     * требования синхронизации на объекте восстановят свой статус-кво - 
     * то есть ситуацию, существующую во время вызова метода <tt>wait</tt>. 
     * В это время поток <var>T</var> вернет управление из вызова метода
     * <tt>wait</tt>. Таким образом, по возврату из метода <tt>wait</tt>, 
     * состояние синхронизации объекта и потока <var>T</var> в точности такое 
     * же, как перед вызовом метода <tt>wait</tt>. (Строго говоря, это не так.
     * Смотрите подробности по ссылке [1].)
     * <p>
     * Поток также может проснуться без уведомления, прерывания или истечения
     * тайм-аута, так называемое <i>побочное пробуждение</i>. Хотя это будет редко
     * происходить на практике, приложения должны принять меры против этого,
     * проверяя условие, которое должно вызвать пробуждение потока, и 
     * продолжать ждать, если это условие не выполнено. Другими словами,
     * ожидание всегда должно происходить в цикле, как-то так:
     * <pre>
     *     synchronized (obj) {
     *         while (&lt;условие не выполняется&gt;)
     *             obj.wait();
     *         ... // Выполняем действия, которые приведут к выполнению условия
     *     }
     * </pre>
     * (Для большей информации по этому вопросу смотрите Section 3.2.3 в Doug Lea's
     * "Concurrent Programming in Java (Second Edition)" (Addison-Wesley,
     * 2000), или Правило 50 в "Java. Эффективное программирование", Джошуа Блох (Лори, 2002) 
     * (Item 50 in Joshua Bloch's "Effective Java Programming Language Guide" (Addison-Wesley, 2001)).
     *
     * <p>Если текущий поток {@linkplain java.lang.Thread#interrupt()
     * прерван} другим потоком до или пока он ожидал, кидается исключение
     * <tt>InterruptedException</tt>. Это исключение не выкидывается, пока
     * статус блокировки этоо объекта не восстановится, как было описано 
     * выше.
     *
     * <p>
     * Учтите, что метод <tt>wait</tt>, так как помещает текущий поток в 
     * очередь ожидания для этого объекта, разблокирует только этот объект; 
     * любые другие объекты, на которых может синхронизироваться текущий 
     * поток, остаются заблокированными, пока поток ожидает.
     * <p>
     * Этот метод должен вызываться только потоком, который владеет 
     * монитором этого объекта. Смотрите метод {@code notify} для 
     * описания способов, которыми поток может стать владельцем монитора.
     * <p>
     * [1] Про синхронизацию отлично написано на {@link http://www.skipy.ru/technics/synchronization.html}
     *
     * @param      timeout   максимальное время ожидания в миллисекундах.
     * @exception  IllegalArgumentException      если значение таймаута
     *                                           отрицательно.
     * @exception  IllegalMonitorStateException  если текущий поток не
     *             является владельцем монитора этого объекта.
     * @exception  InterruptedException если какой-то поток прервал текущий
     *             поток до или во время ожидания текущим потоком 
     *             уведомления. <i>Состояние прерывания</i> текущего
     *             потока очищается при выкидывании этого исключения.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final native void wait(long timeout) throws InterruptedException;

    /**
     * Заставляет текущий поток ждать до тех пор, пока какой-нибудь другой 
     * поток не вызовет метод {@link java.lang.Object#notify()} или 
     * {@link java.lang.Object#notifyAll()} для этого объекта, или 
     * некоторый другой поток не прервет текущий поток или не пройдет 
     * указанное количество реального времени. 
     * <p>
     * Этот метод похож на метод {@code wait} с одним аргументом,
     * но позволяет более тонко контролировать время ожидания уведомления
     * перед отказом от ожидания. Количество реального времени, измеренное 
     * в наносекундах, дает:
     * <blockquote>
     * <pre>
     * 1000000*timeout+nanos</pre></blockquote>
     * <p>
     * Во всех остальных отношениях этот метод делает то же самое, что и 
     * метод {@link #wait(long)} с одним аргументом. В частности, 
     * <tt>wait(0, 0)</tt> означает то же самое, что и <tt>wait(0)</tt>.
     * <p>
     * Текущий поток должен владеть монитором этого объекта. Поток 
     * отпускает владение этим монитором и ожидает, пока произойдет любое
     * из следующих двух условий: 
     * <ul>
     * <li>Другой поток уведомит потоки, ожидающие на мониторе этого объекта, 
     *     пробуждая их, или вызовом метода {@code notify} или метода 
     *     {@code notifyAll}. 
     * <li>Истекет период тайм-аута, указанный аргументами {@code timeout} 
     *     миллисекунд плюс {@code nanos} наносекунд.
     * 
     * </ul>
     * <p>
     * Поток ожидает, пока он снова не сможет завладеть монитором 
     * и возобновить исполнение.
     * <p>
     * Как и в версии с одним аргументом, возможны прерывания и побочные 
     * пробуждения, и этот метод должен всегда использоваться в цикле:
     * <pre>
     *     synchronized (obj) {
     *         while (&lt;условие не выполняется&gt;)
     *             obj.wait(0, 0);
     *         ... // Выполняем действия, которые приведут к выполнению условия
     *     }
     * </pre>
     * Этот метод должен вызываться только потоком, который владеет 
     * монитором этого объекта. Смотрите метод {@code notify} для 
     * описания способов, которыми поток может стать владельцем монитора.
     * <p>
     * Про синхронизацию отлично написано на {@link http://www.skipy.ru/technics/synchronization.html}
     *
     * @param      timeout   максимальное время для ожидания в миллисекундах.
     * @param      nanos     дополнительное время, в наносекундах в диапазоне
     *                       0-999999.
     * @exception  IllegalArgumentException      если значение таймаута
     *             отрицательно или значения наносекунд не в диапазоне
     *             0-999999.
     * @exception  IllegalMonitorStateException  если текущий поток не
     *             является владельцем монитора этого объекта.
     * @exception  InterruptedException если какой-то поток прервал текущий
     *             поток до или во время ожидания текущим потоком 
     *             уведомления. <i>Состояние прерывания</i> текущего
     *             потока очищается при выкидывании этого исключения.
     */
    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                "nanosecond timeout value out of range");
        }

        if (nanos >= 500000 || (nanos != 0 && timeout == 0)) {
            timeout++;
        }

        wait(timeout);
    }

    /**
     * Заставляет текущий поток ждать до тех пор, пока какой-нибудь другой 
     * поток не вызовет метод {@link java.lang.Object#notify()} или 
     * {@link java.lang.Object#notifyAll()} для этого объекта.
     * Другими словами, этот метод ведет себя так, как если бы он просто 
     * вызвал <tt>wait(0)</tt>.
     * <p>
     * Текущий поток должен владеть монитором этого объекта. Поток отпускает
     * владение этим монитором и ожидает, пока другой поток не уведомит 
     * ожидающие на мониторе этого объекта потоки пробудится, вызвав метод
     * {@code notify}, либо метод {@code notifyAll}. Затем поток ждет,
     * пока он сможет вновь получить владение монитором и возобновляет 
     * исполнение.
     * <p>
     * Как и в версии с одним аргументом, возможны прерывания и побочные 
     * пробуждения, поэтому этот метод всегда должен использоваться в цикле:
     * <pre>
     *     synchronized (obj) {
     *         while (&lt;условие не выполняется&gt;)
     *             obj.wait();
     *         ... // Выполняем действия, которые приведут к выполнению условия
     *     }
     * </pre>
     * Этот метод должен вызываться только потоком, который владеет 
     * монитором этого объекта. Смотрите метод {@code notify} для 
     * описания способов, которыми поток может стать владельцем монитора.
     * <p>
     * Про синхронизацию отлично написано на {@link http://www.skipy.ru/technics/synchronization.html}
     *
     * @exception  IllegalMonitorStateException  если текущий поток не
     *             является владельцем монитора этого объекта.
     * @exception  InterruptedException если какой-то поток прервал текущий
     *             поток до или во время ожидания текущим потоком 
     *             уведомления. <i>Состояние прерывания</i> текущего
     *             потока очищается при выкидывании этого исключения.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final void wait() throws InterruptedException {
        wait(0);
    }

    /**
     * Вызывается сборщиком мусора на объекте, когда сборщик мусора 
     * определяет, что на объект больше нет ссылок.
     * Подклассы overrides the {@code finalize} method to dispose of
     * system resources or to perform other cleanup. 
     * <p>
     * Общее соглашение для <tt>finalize</tt> состоит в том, что он вызыватеся
     * тогда и только тогда, когда виртуальная машина 
     * Java<font size="-2"><sup>TM</sup></font> определила, что больше нет 
     * никого, через кого этот объект мог быть доступен из любого потока, 
     * который еще не умер, за исключением случаев, когда как результат 
     * действий финализации другого объекта или класса, который готов быть 
     * финализирован. Метод <tt>finalize</tt> может делать любые действия, 
     * включая делание объекта снова доступным для других потоков; обычная
     * цель <tt>finalize</tt>, однако, состоит в выполнении действий по 
     * очистке, прежде чем объект будет безвозвратно утерян. Например, метод 
     * финализации  для объекта, представляющего соединение ввода/вывода, 
     * может выполнить явные I/O транзакции для разрыва соединения прежде, 
     * чем объект будет окончательно потерян.
     * <p>
     * Метод <tt>finalize</tt> класса <tt>Object</tt> не выполняет никаких 
     * специальных действий; он просто возвращает управление немедленно. 
     * Подклассы <tt>Object</tt> may override this definition.
     * <p>
     * Язык программирования Java не гарантирует, какой поток вызовет метод
     * <tt>finalize</tt> для любого данного объекта. Он гарантирует, однако,
     * что поток, вызывающий финализацию, не будет хранить какие-либо видимые
     * пользователю синхронизационные блокировки, когда вызовется финализация.
     * Если неперехваченное исключение будет выкинуто методом <tt>finalize</tt>, 
     * исключение будет проигнорировано, а финализация объекта прервана.
     * <p>
     * После того, как для объекта был вызван метод <tt>finalize</tt>, никаких
     * дальнейших действий не предпринимается, пока виртуальная машина Java 
     * повторно не определит, что больше нет никого, кто мог бы получить
     * доступ к этому объекту из какого-либо еще не умершего потока, включая
     * возможные действия других объектов или классов, которые готовы быть
     * финализированы, после этого этапа объект может быть уничтожен.
     * <p>
     * Метод <tt>finalize</tt> никогда не вызывается более одного раза 
     * виртуальной машиной Java для любого объекта.
     * <p>
     * Любые исключения, выкинутые методом {@code finalize}, приведут к 
     * остановке финализации этого объекта, но в остальном будут
     * проигнорированы. 
     *
     * @throws Throwable Исключение, выкинутое этим методом.
     */
    protected void finalize() throws Throwable { }
}
