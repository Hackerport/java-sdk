/*
 * @(#)Process.java	1.26 10/03/23
 *
 * Копирайт (c) 2006, Oracle и/или его филиалы. Все права защищены.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Использовать в соответствии с лицензией.
 */

package java.lang;

import java.io.*;

/**
 * Методы {@link ProcessBuilder#start()} и
 * {@link Runtime#exec(String[],String[],File) Runtime.exec}
 * создают "родной" процесс и возвращают инстанцию подкласса
 * {@code Process}, которая может использоваться для управления
 * процессом и получения информации о нем.
 * Класс {@code Process} предоставляет методы для выполнения ввода из
 * процесса, выполнения вывода в процесс, ожидание завершения процесса,
 * проверка кода выхода процесса и уничтожение (убивание) процесса.
 *
 * <p>
 * Методы, которые создают процессы, могут не работать корректно для специальных
 * процессов на определенных родных платформах, такие, как родные оконные
 * процессы, процессы-демоны, Win16/DOS процессы на Microsoft Windows, или
 * скрипты оболочки. Создаваемые подпроцессы не имеют своего собственного
 * терминала или консоли. Все их стандартные операции ввода/вывода (т.е. 
 * stdin, stdout, stderr) будут перенаправлены в родительский процесс, 
 * через три потока:
 * ({@link #getOutputStream()},
 * {@link #getInputStream()},
 * {@link #getErrorStream()}).
 * Родительский процесс использует эти потоки для подачи ввода и получения 
 * вывода из подпроцесса. Поскольку некоторые родные платформы предоставляют
 * ограниченный буфер для стандартных потоков ввода и вывода, неспособность
 * своевременно писать во входной поток или читать из выходного потока 
 * подпроцесса может привести к блокировке подпроцесса и даже к взаимной 
 * блокировке (deadlock-у).
 *
* <p>
 * Подпроцессы не убиваются, когда больше не останется ссылок но объект
 * {@code Process}, а будет, скорее всего продолжать выполняться асинхронно.
 *
 * <p>
 * Нет никаких требований, что процесс, представляемый объектом {@code Process},
 * должен выполняться асинхронно или параллельно относительно процесса Java,
 * владеющего объектом {@code Process}.
 *
 * @author  unascribed
 * @version 1.26, 03/23/10
 * @see     ProcessBuilder
 * @see     Runtime#exec(String[], String[], File)
 * @since   JDK1.0
 */
public abstract class Process
{
    /**
     * Получает выходной поток подпроцесса.
     * Вывод в поток идет по каналу в стандартный поток ввода процесса,
     * представляемого этим объектом {@code Process}.
     * <p>
     * Замечание по реализации: хорошая идея для выходного потока быть 
     * буферезированным.
     *
     * @return  выходной поток, присоединенный к нормальному входному потоку
     *          подпроцесса.
     */
    abstract public OutputStream getOutputStream();

    /**
     * Получает входной поток подпроцесса.
     * Поток получает данные, передаваемые по каналу из стандартного потока
     * вывода процесса, представляемого этим объектом {@code Process}.
     * <p>
     * Замечание по реализации: хорошая идея для входного потока быть 
     * буферезированным.
     *
     * @return  входной поток, присоединенный к нормальному выходному потоку
     *          подпроцесса.
     * @see ProcessBuilder#redirectErrorStream()
     */
    abstract public InputStream getInputStream();

    /**
     * Получает поток ошибок подпроцесса.
     * Поток получает данные, передаваемые по каналу из потока ошибок
     * процесса, представляемого этим объектом {@code Process}.
     * <p>
     * Замечание по реализации: хорошая идея для входного потока быть 
     * буферезированным.
     *
     * @return  входной поток, присоединенный к потоку ошибок
     *          подпроцесса.
     * @see ProcessBuilder#redirectErrorStream()
     */
    abstract public InputStream getErrorStream();

    /**
     * Заставляет текущий поток ждать, если необходимо, пока процесс,
     * представляемый этим объектом {@code Process}, не будет завершен.
     * Этот метод возвращает управление сразу, если подпроцесс
     * уже был завершен. Если подпроцесс еще не завершен,
     * вызывающий поток будет блокирован до тех пор, пока подпроцесс
     * не завершится.
     *
     * @return     код возврата процесса. По соглашению, значение
     *             {@code 0} говорит о нормальном завершении.
     * @exception  InterruptedException  если текущий поток
     *             {@linkplain Thread#interrupt() прерван} другим потоком,
     *             пока он ожидал, то ожидание заканчивается и кидается
     *             {@link InterruptedException}.
     */
    abstract public int waitFor() throws InterruptedException;

    /**
     * Возвращает код возврата для подпроцесса.
     *
     * @return  код возврата подпроцесса, представляемого этип объектом
     *          {@code Process}. По соглашению, значение
     *          {@code 0} говорит о нормальном завершении.
     * @exception  IllegalThreadStateException  если подпроцесс, представляемый
     *             этим объектом {@code Process}, еще не был завершен.
     */
    abstract public int exitValue();

    /**
     * Убивает подпроцесс. Подпроцесс, представляемый этим объектом
     * {@code Process}, принудительно завершается.
     */
    abstract public void destroy();
}
