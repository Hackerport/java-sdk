/*
 * @(#)Comparable.java	1.27 10/03/23
 *
 * Копирайт (c) 2006, Oracle и/или его филиалы. Все права защищены.
 * ORACLE PROPRIETARY/CONFIDENTIAL. Использовать в соответствии с лицензией.
 */

package java.lang;
import java.util.*;

/**
 * Этот интерфейс налагает линейную упорядоченность на объекты каждого класса,
 * реализующего его. Этот порядок называется <i>естественным порядком</i>, 
 * класса и метод класса <tt>compareTo</tt> называется его <i>методом 
 * естественного сравнения</i>.<p>
 *
 * Списки (и массивы) объектов, которые реализуют этот интерфейс, автоматически могут
 * сортироваться с помощью {@link Collections#sort(List) Collections.sort} (и
 * {@link Arrays#sort(Object[]) Arrays.sort}). Объекты, которые реализуют этот
 * интерфейс, могут использоваться как ключи в {@linkplain SortedMap сортированных картах} 
 * или как элементы в {@linkplain SortedSet сортированных множествах}, без необходимости
 * указывать {@linkplain Comparator компаратор}.<p>
 *
 * Говорят, что естественное упорядочивание для класса <tt>C</tt> является 
 * <i>непротиворечивым со сравнением</i> тогда и только тогда, когда {@code e1.compareTo(e2) == 0} 
 * имеет то же самое булево значение, что и {@code e1.equals(e2)} для любых инстанций
 * <tt>e1</tt> и <tt>e2</tt> класса <tt>C</tt>. Заметьте, что <tt>null</tt>
 * не является инстанцией какого-либо класса, поэтому {@code e.compareTo(null)} должно
 * выкинуть <tt>NullPointerException</tt> даже при том, что {@code e.equals(null)}
 * возвращает <tt>false</tt>.<p>
 *
 * Строго рекомендуется (хотя и не требуется), чтобы естественное упорядочивание
 * было непротиворечиво со сравнением. Это вытекает из того, что сортированные
 * множества  (и сортированные карты) без явных компараторов ведут себя "странно",
 * когда они используются с элементами (или ключами), чей естественный порядок
 * противоречит сравнению. В частности такое сортированное множество (или
 * сортированная карта) нарушает общее соглашение для множеств (или карт),
 * которое определено в терминах метода {@code equals}.<p>
 *
 * Например, если вы добавляете два ключа <tt>a</tt> и <tt>b</tt>, такие, что
 * {@code (!a.equals(b) && a.compareTo(b) == 0)} в сортированное множество,
 * которое не использует явный компаратор, вторая операция {@code add}
 * вернет {@code false} (и размер сортированного множества не увеличится),
 * потому что <tt>a</tt> и <tt>b</tt> эквивалентны с точки зрения сортированного
 * множества.<p>
 *
 * Фактически все классы ядра Java, которые реализуют {@code Comparable}, имеют 
 * естественный порядок, непротиворечивый со сравнением. Единственое исключение -
 * {@code java.math.BigDecimal, чей естественный порядок считает равными объекты
 * {@code BigDecimal} с равными значениями, но различной точностью
 * (такие, как 4.0 и 4.00).<p>
 *
 * В более строгой математической формулировке, <i>отношение</i>, которое
 * определяет естественное сравнение на данном классе <tt>C</tt> есть:<pre>
 *       {(x, y) такие, что x.compareTo(y) &lt;= 0}.
 * </pre> <i>Частное</i> для этого полного порядка есть: <pre>
 *       {(x, y) такие, что x.compareTo(y) == 0}.
 * </pre>
 *
 * Это однозначно следует из соглашения для {@code compareTo}, что частное это
 * <i>отношение эквивалентности</i> на <tt>C</tt>, и что естественный порядок
 * является <i>линейным порядком</i> на <tt>C</tt>. Когда мы говорим, что 
 * естесвенный порядок класса является <i>непротиворечивым со сравнением</i>, мы подразумеваем,
 * что частное для естественного порядка есть отношение эквивалентности, определенное 
 * через метод класса {@link Object#equals(Object) equals(Object)}:<pre>
 *     {(x, y) такие, что x.equals(y)}. </pre><p>
 *
 * Этот интерфейс является частью
 * <a href="{@docRoot}/../technotes/guides/collections/index.html">
 * Фреймворка коллекций Java</a>.
 *
 * @param <T> тип объектов, с которым этот объект может сравниваться
 *
 * @author  Josh Bloch
 * @version 1.27, 03/23/10
 * @see java.util.Comparator
 * @since 1.2
 */

public interface Comparable<T> {
    /**
     * Устанавливает отношение порядка этого объекта с указанным. Возвращает
     * отрицательное число, ноль или положительное число, когда этот объект
     * меньше, чем, равен или больше, чем указанный объект.
     *
     * <p>Реализатор должен гарантировать, что {@code sgn(x.compareTo(y)) ==
     * -sgn(y.compareTo(x))} для любых <tt>x</tt> и <tt>y</tt>. (Это
     * подразумевает, что {@code x.compareTo(y)} должно выкидывать исключение
     * тогда и только тогда, когда {@code y.compareTo(x)} кидает исключение).
     *
     * <p>Реализатор также должен гарантировать, что отношение транзитивно:
     * {@code (x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z)&gt;0)} подразумевает
     * что {@code x.compareTo(z)&gt;0}.
     *
     * <p>Наконец, реализатор должен гарантировать, что {@code x.compareTo(y)==0}
     * подразумевоет, что {@code sgn(x.compareTo(z)) == sgn(y.compareTo(z))}, для
     * любых <tt>z</tt>.
     *
     * <p>Строго рекомендуется, но <i>не</i> обязательно требуется, чтобы
     * {@code (x.compareTo(y)==0) == (x.equals(y))}. Вообще говоря, любой
     * класс, реализующий интерфейс {@code Comparable} и нарушающий это
     * условие, должен ясно указывать этот факт. Рекомендованная форма:
     * "Внимание: этот класс имеет естественный порядок, противоречивый со
     * сравнением."
     *
     * <p>В предыдущем описании нотация <tt>sgn(</tt><i>выражение</i><tt>)</tt>
     * описывает математическую функцию <i>знака числа</i>, которая определяется,
     * как возвращающая <tt>-1</tt>, <tt>0</tt> или <tt>1</tt> в зависимости
     * от того, является ли значение <i>выражения</i> отрицательным,
     * нулевым или положительным.
     *
     * @param   o объект для сравнения.
     * @return  отрицательное число, ноль или положительное число, когда этот
     *          объект меньше, чем, равен или больше, чем указанный объект.
     *
     * @throws ClassCastException если тип указанного объекта препятствует
     *         его сравнению с этим объектом.
     */
    public int compareTo(T o);
}
